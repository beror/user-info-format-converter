<!DOCTYPE html>
<html>
<head>
  <title>Converter</title>
</head>

<body style='background-color: #222; color: #eee;'>
  <label for='fileInput'>Upload the file:</label>
  <input id='fileInput' type='file' style='cursor: pointer;'>

  <div>
    <label for='customNameInput'>Name:</label>
    <input id='customNameInput' type='text'>
  </div>

  <div>
    <label for='outputFormatSelect'>Output format:</label>
    <select id='outputFormatSelect'>
      <option value='name::token::userAgent'>Название :: access_token :: User agent</option>
    </select>
  </div>

  <div>
    <span>File reading progress:</span>
    <span id='loadedCounter'>-</span>
    <span>/</span>
    <span id='total'>-</span>
  </div>

  <script type='text/javascript'>
    const fileInput = document.getElementById('fileInput');
    const loadedCounterElem = document.getElementById('loadedCounter');
    const totalElem = document.getElementById('total');

    const fileReader = new FileReader();

    fileInput.onchange = ({target: {files}}) => fileReader.readAsText(files[0]);

    fileReader.onprogress = event => {
      loadedCounter.innerText = event.loaded;
      totalElem.innerText = event.total;
    };

    fileReader.onload = event => {
      loadedCounter.innerText = event.loaded;
      totalElem.innerText = event.total;

      const linesInFile = fileReader.result.split(/\r\n|\n/); // Each line contains one account
      if(linesInFile[linesInFile.length - 1] === '') linesInFile.splice(linesInFile.length - 1);

      const infoPiecesArraysMap = {
        logins: [],
        passwords: [],
        tokens: [],
        userAgents: [],
        cookies: []
      };

      linesInFile.forEach(line => {
        const infoPiecesInLine = line.split(/\t|\||:/); // An info piece is a single piece of certain part of the account (i.e. the token, the user agent etc.)

        let wasLoginParsedInThisLine = false;

        let wasLoginThePreviousInfoPiece = false; // Needed for password parsing. Password is assumed to come immediately after the login

        let isCollectingACookie = false;
        let collectedCookie = '';

        infoPiecesInLine.forEach(infoPiece => {
          if(isCollectingACookie) {
            collectedCookie += ':' + infoPiece; // Adding ":" back in because it was a separator
            if(infoPiece.endsWith('}]')) {
              isCollectingACookie = false;
            }
          }
          else if(wasLoginThePreviousInfoPiece) {
            infoPiecesArraysMap.passwords.push(infoPiece);
            wasLoginThePreviousInfoPiece = false;
          }
          else if(infoPiece.startsWith('EAAB')) infoPiecesArraysMap.tokens.push(infoPiece);
          else if(infoPiece.startsWith('Mozilla/5.0')) infoPiecesArraysMap.userAgents.push(infoPiece);
          else if(/@rambler.ru|@kiratopmail.site|@yahoo.com|@outlook.com|@inbox.ru|@hotmail.com/.test(infoPiece)) {
            const email = infoPiece.split(/:|\|/)[0];
            infoPiecesArraysMap.logins.push(email);
            wasLoginParsedInThisLine = true;
            wasLoginThePreviousInfoPiece = true;
          }
          else if(!wasLoginParsedInThisLine && /^\d+$/.test(infoPiece)) {
            infoPiecesArraysMap.logins.push(infoPiece);
            wasLoginParsedInThisLine = true;
            wasLoginThePreviousInfoPiece = true;
          }
          else if(/^(\[{"name"|\[{"domain"|\[{"expirationDate")/.test(infoPiece)) {
            collectedCookie += infoPiece;
            isCollectingACookie = true;
          }
        });

        infoPiecesArraysMap.cookies.push(collectedCookie);
      });

      const longestArrayLength = Math.max(
        ...Object.values(infoPiecesArraysMap).map(a => a.length)
      );

      // TODO: fix abstraction failure that starts here

      const outputFormat = document.getElementById('outputFormatSelect').value;

      let infoPiecesToOutput;
      switch(outputFormat) {
        case 'name::token::userAgent': {
          infoPiecesToOutput = [
            infoPiecesArraysMap.tokens,
            infoPiecesArraysMap.userAgents
          ];
          break;
        }
        default: {
          infoPiecesToOutput = Object.values(infoPiecesArraysMap);
          break;
        }
      }

      renderDownloadFileButton(
        getFormattedOutputObjectUrl(infoPiecesArraysMap)
      );

      renderCopyToClipboardButton(
        getOutputString([
          getCustomNames(longestArrayLength),
          ...infoPiecesToOutput
        ])
      );

      renderResultPreview(infoPiecesArraysMap);

      // and ends here
    };

    const getFormattedOutputObjectUrl = (infoPiecesArraysMap) => { // TODO: prevent objectURL creating a memory leak. Also this function is not pure
      const outputFormat = document.getElementById('outputFormatSelect').value;
      let objectUrl;

      switch(outputFormat) {
        case 'name::token::userAgent': {
          const infoPiecesToOutput = [
                                      infoPiecesArraysMap.tokens,
                                      infoPiecesArraysMap.userAgents
                                     ];
          const biggestArrayLength = Math.max(
            ...infoPiecesToOutput.map(a => a.length)
          );
          objectUrl = URL.createObjectURL(
            getBlobifiedFormattedInfoPiecesArrays(
              [getCustomNames(biggestArrayLength), ...infoPiecesToOutput]
            )
          );
          break;
        }
        default: {
          const infoPiecesToOutput = Object.values(infoPiecesArraysMap);
          const biggestArrayLength = Math.max(
            ...infoPiecesToOutput.map(a => a.length)
          );
          objectUrl = URL.createObjectURL(
            getBlobifiedFormattedInfoPiecesArrays(
              [getCustomNames(biggestArrayLength), ...infoPiecesToOutput]
            )
          );
          break;
        }
      }

      return objectUrl;
    };

    const getOutputString = (infoPiecesArrays) => {
      let outputString = '';
      const longestInfoPiecesArrayLength = Math.max(...infoPiecesArrays.map(a => a.length));

      for(let i = 0; i < longestInfoPiecesArrayLength; i++) {
        infoPiecesArrays.forEach((infoPieces, idx) => {
          const infoPiece = infoPieces[i] || '';
          outputString += idx === 0 ? infoPiece : ' :: ' + infoPiece;
        });
        outputString += '\n';
      }

      return outputString;
    };

    const getCustomNames = (length) => {
      const customName = document.getElementById('customNameInput').value;

      return customName && new Array(length)
                            .fill(undefined)
                            .map((_, i) => `${customName}-${i+1}`);
    };

    const getBlobifiedFormattedInfoPiecesArrays = (infoPiecesArrays) => new Blob(
      [getOutputString(infoPiecesArrays)],
      {type: 'text/plain'}
    );

    const renderDownloadFileButton = (objectUrlToDownload) => {
      const downloadButton = document.createElement('button');
      downloadButton.innerText = 'Download the output file';
      downloadButton.style.cursor = 'pointer';

      const a = document.createElement('a');
      a.href = objectUrlToDownload;
      a.download = 'test.txt';
      a.style.display = 'block';
      a.style.width = 'fit-content';

      a.append(downloadButton);
      document.body.lastElementChild.before(a);
    };

    const renderCopyToClipboardButton = (stringToCopy) => {
      const copyToClipboardButton = document.createElement('button');
      copyToClipboardButton.innerText = 'Copy the result to clipboard';
      copyToClipboardButton.style.cursor = 'pointer';
      copyToClipboardButton.onclick = () => navigator.clipboard.writeText(stringToCopy);

      document.body.lastElementChild.before(copyToClipboardButton);
    };

    const renderResultPreview = (infoPiecesArrays) => {
      try {
        const headers = Object.keys(infoPiecesArrays);

        const table = document.createElement('table');
        table.id = 'resultTable';
        table.style.minWidth = '100%';
        table.style.border = '1px solid #666';
        table.style.borderCollapse = 'collapse';

        const tableCaption = document.createElement('caption');
        tableCaption.innerText = 'Result preview';
        tableCaption.style.fontSize = '22px';
        tableCaption.style.fontWeight = 'bold';
        table.append(tableCaption);

        const headerRow = document.createElement('tr');
        headers.forEach(header => {
          const headerCell = document.createElement('th');
          headerCell.innerText = header;
          headerCell.style.borderRight = '1px solid #666';
          headerRow.append(headerCell);
        });
        table.append(headerRow);

        const longestInfoPiecesArrayLength = Math.max(...Object.values(infoPiecesArrays).map(a => a.length));

        for(let i = 0; i < longestInfoPiecesArrayLength; i++) {
          const newRow = document.createElement('tr');

          Object.values(infoPiecesArrays).forEach(infoPieces => {
            const infoPiece = infoPieces[i];

            const newCell = document.createElement('td');
            newCell.innerText = infoPiece?.length > 70 ? infoPiece.substring(0, 60) + '...' + infoPiece.slice(-8) : infoPiece || '';
            newCell.style.borderRight = '1px solid #666';
            newCell.style.padding = '10px';

            newRow.append(newCell);
          });

          table.append(newRow);
        }

        document
          .body
          .lastElementChild
          .previousElementSibling
          .after(table);
      } catch (error) {
        const errorDiv = document.createElement('div');
        errorDiv.innerText = 'An error has occured: ' + error;
        errorDiv.style.border = '1px solid red';
        document.body.lastElementChild.before(errorDiv);
      }
    };
  </script>
</body>
</html> 